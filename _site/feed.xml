<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Elegit</title>
    <description>The version control system Git has become popular for developers who track and share code. Elegit is a Git client for people who actually want to learn Git. The goal of this project is to design and build a new Git client for use by students that helps them use Git successfully with a minimum of challenges, likely by use of a subset of Git commands, but also specifically with the goal of helping them learn at a deeper level how Git works.
</description>
    <link>http://dmusican.github.io/Elegit/</link>
    <atom:link href="http://dmusican.github.io/Elegit/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 15 Aug 2016 08:39:53 -0500</pubDate>
    <lastBuildDate>Mon, 15 Aug 2016 08:39:53 -0500</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>What is Git Commit?</title>
        <description>&lt;p&gt;Anyone who has successfully used Git in any form has probably used the 
command &lt;code class=&quot;highlighter-rouge&quot;&gt;git commit&lt;/code&gt;. In its most basic form, with just a commit message, 
this does a few things: it stores the files in the staging area, or index, 
in a new commit with a log message from the user, which is supposed to 
describe the changes (but is more often than not “asdf”) and it updates 
the current branch to have a head at the latest commit. Simple, right?&lt;/p&gt;

&lt;p&gt;Wait, what does any of that mean? “Storing files in the index in a commit”? 
Well, Git is all about being lightweight and not storing anything it doesn’t 
need to, so this means that Git doesn’t want to have complete copies of 
every single file for every single commit. You might ask, why not just 
store what changed? This would be correct for most other version control 
systems like CVS, Subversion, Perforce, Bazaar, etc., but Git doesn’t do this. 
Git takes “snapshots” of the files in the directory you’re tracking. 
A snapshot will just include a pointer to a previous snapshot if a particular 
file hasn’t changed, but will store new versions. If you were to look at 
the actual data of a commit, you would see the content of all the files 
that Git is tracking. This supposedly makes Git more powerful in terms 
of branching, but that’s for another day.&lt;/p&gt;

&lt;p&gt;Anyway, Git stores a beautiful “snapshot” in the local repository, then 
it also changes the contents of two files to be the commit hash 
(the 40-character fa90c29… that you see after the commit happens). 
These files happen to be &lt;code class=&quot;highlighter-rouge&quot;&gt;.git/refs/heads/&amp;lt;current branch name&amp;gt;&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;.git/HEAD&lt;/code&gt;, 
which are just Git’s place to store the head of the specified branch 
(note, it’s a pointer, not a full commit) and the head of the current branch.&lt;/p&gt;

&lt;p&gt;So, Git has created a new commit and updated a branch head. What about the other things that you can do? 
Answer is: way more than you ever wanted to do or even think about. 
Commit has a number of parameters, as can be seen in the synopsis of the help page:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-git&quot; data-lang=&quot;git&quot;&gt;git commit [-a | --interactive | --patch] [-s] [-v] [-u&amp;lt;mode&amp;gt;] [--amend]
	   [--dry-run] [(-c | -C | --fixup | --squash) &amp;lt;commit&amp;gt;]
	   [-F &amp;lt;file&amp;gt; | -m &amp;lt;msg&amp;gt;] [--reset-author] [--allow-empty]
	   [--allow-empty-message] [--no-verify] [-e] [--author=&amp;lt;author&amp;gt;]
	   [--date=&amp;lt;date&amp;gt;] [--cleanup=&amp;lt;mode&amp;gt;] [--[no-]status]
	   [-i | -o] [-S[&amp;lt;keyid&amp;gt;]] [--] [&amp;lt;file&amp;gt;…​]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;How do we read this? It means &lt;code class=&quot;highlighter-rouge&quot;&gt;git commit&lt;/code&gt; can be followed by these things. Let’s take them one brace at a time:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[-a | --interactive | --patch]&lt;/code&gt;: these say how to choose which files to look at. &lt;code class=&quot;highlighter-rouge&quot;&gt;Git commit&lt;/code&gt; 
just looks at the index, but adding -a will look at all files in the working 
directory that are also in the index, and stage changes in modified files.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--interactive or --patch&lt;/code&gt; will give you an interface to choose which changes to commit.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-s/--signoff&lt;/code&gt;: this will automatically add a signed-off by line by the 
committer at the end of the commit message. This typically is used to certify 
that a committer has the rights to submit the particular commit&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-v/--verbose&lt;/code&gt;: this will show the diff between the current HEAD commit 
and what would be committed at the bottom of the message template that is 
generated, useful for writing commit messages so you can see what you did.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-u[&amp;lt;mode&amp;gt;]/--untracked-files[=&amp;lt;mode&amp;gt;]&lt;/code&gt;: shows the untracked files. The 
mode can be &lt;code class=&quot;highlighter-rouge&quot;&gt;no&lt;/code&gt;: show no untracked files, &lt;code class=&quot;highlighter-rouge&quot;&gt;normal&lt;/code&gt;: show untracked files 
in the root directory and untracked directories, and &lt;code class=&quot;highlighter-rouge&quot;&gt;all&lt;/code&gt;: show all 
untracked files, even those in untracked directories. Usage looks like 
&lt;code class=&quot;highlighter-rouge&quot;&gt;git commit -uno&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;git commit --untracked-files=all&lt;/code&gt;. The default when using &lt;code class=&quot;highlighter-rouge&quot;&gt;-u&lt;/code&gt; 
is all and when not using it, the default is &lt;code class=&quot;highlighter-rouge&quot;&gt;normal&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--amend&lt;/code&gt;: this one is to be used responsibly. If you ‘accidentally’ wrote “asdf” 
as your commit message, or forgot to include a file in a commit, you can 
amend the head of the current branch with this. If you do &lt;code class=&quot;highlighter-rouge&quot;&gt;git commit --amend&lt;/code&gt;, 
command line will pull up an editor that has the previous commit message already in it, 
then once you finish writing your commit message, this new commit will replace the 
old head of the current branch. This commit will have the same parent(s) 
and authors as the current commit, but DO NOT USE if this commit has already 
been published. Rewriting history is bad.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--dry-run&lt;/code&gt;: this is for those who don’t have Git magic (e.g. me, you, everyone…) 
and want to know what the heck will happen when you press enter with a 
complicated command. For example, &lt;code class=&quot;highlighter-rouge&quot;&gt;git commit -a --dry-run&lt;/code&gt; will show you 
all files that will be committed or not if you run the command &lt;code class=&quot;highlighter-rouge&quot;&gt;git commit -a&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[(-c | -C | --fixup | --squash) &amp;lt;commit&amp;gt;]&lt;/code&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;-C &amp;lt;commit&amp;gt;/--reuse-message=&amp;lt;commit&amp;gt;&lt;/code&gt; 
will reuse the log message and authorship from &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;-c &amp;lt;commit&amp;gt;/--reedit-message=&amp;lt;commit&amp;gt;&lt;/code&gt; 
does the same thing as &lt;code class=&quot;highlighter-rouge&quot;&gt;-C&lt;/code&gt;, but will show you the editor before actually making changes. 
&lt;code class=&quot;highlighter-rouge&quot;&gt;--fixup=&amp;lt;commit&amp;gt;&lt;/code&gt; will make a commit that is to be used with rebase &lt;code class=&quot;highlighter-rouge&quot;&gt;--autosquash&lt;/code&gt; 
with the message of &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; prefixed by “fixup! ”. Finally &lt;code class=&quot;highlighter-rouge&quot;&gt;--squash=&amp;lt;commit&amp;gt;&lt;/code&gt; 
does the same thing as &lt;code class=&quot;highlighter-rouge&quot;&gt;--fixup&lt;/code&gt;, but uses the prefix “squash! “, and can be used 
with the options &lt;code class=&quot;highlighter-rouge&quot;&gt;-m&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;-c&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;-C&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;-F&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[-F &amp;lt;file&amp;gt; | -m &amp;lt;msg&amp;gt;]&lt;/code&gt;: this specifies the message of the commit. &lt;code class=&quot;highlighter-rouge&quot;&gt;-F&lt;/code&gt; 
will take the commit message from the specified files, &lt;code class=&quot;highlighter-rouge&quot;&gt;-m&lt;/code&gt; 
will take it from the next input. For example: &lt;code class=&quot;highlighter-rouge&quot;&gt;git commit -m “Added 9001 files and beat Goku in single combat”&lt;/code&gt; 
adds a commit with that message.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--reset-author&lt;/code&gt;: this is used with the &lt;code class=&quot;highlighter-rouge&quot;&gt;-C&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;-c&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;--amend&lt;/code&gt; options, and will 
make the author of the commit you, rather than whoever made the commit you’re changing.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--allow-empty&lt;/code&gt;: this allows you to commit with no changes. Not recommended by me.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Whew… halfway! We’ll cover the rest in the next iteration of this post.&lt;/p&gt;
</description>
        <pubDate>Fri, 12 Aug 2016 01:50:00 -0500</pubDate>
        <link>http://dmusican.github.io/Elegit/jekyll/update/2016/08/12/what-is-commit.html</link>
        <guid isPermaLink="true">http://dmusican.github.io/Elegit/jekyll/update/2016/08/12/what-is-commit.html</guid>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
      <item>
        <title>What is Git Revert?</title>
        <description>&lt;p&gt;Great. Some genius decided it would be fun to put in 300 useless changes, 
but it’s 72 commits ago. You can’t do a reset because you need those 72 
commits, but you want to undo those changes, and not by hand. Enter &lt;code class=&quot;highlighter-rouge&quot;&gt;git revert&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Git revert&lt;/code&gt; is relatively limited in the scope of things it does, 
which is nice, so here’s how to use the command line version of it:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-git&quot; data-lang=&quot;git&quot;&gt;git revert [--[no-]edit] [-n] [-m parent-number] [-s] [-S[&amp;lt;keyid&amp;gt;]] &amp;lt;commit&amp;gt;…​
git revert --continue
git revert --quit
git revert --abort&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Basically, git revert takes your current files, and deletes any changes 
from the commit(s) you give it, making a new commit. Options you have are:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-e/--edit&lt;/code&gt;: edit the commit message before committing the revert 
(this is default, add the no- between dashes and ‘edit’ to make it not ask you to write a message)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-m parent-number/--mainline parent-number&lt;/code&gt;: this lets you revert a 
merge (which you usually can’t do because Git has no way of knowing which 
parent was the one you want). However note that this makes it so that 
future merges will not include any changes that are part of a commit 
that was an ancestor to the reverted merge. For a complete explanation 
of reverts and how to use them in this case, see https://github.com/git/git/blob/master/Documentation/howto/revert-a-faulty-merge.txt&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-n/--no-commit&lt;/code&gt;: if you don’t want a commit to be automatically 
created by the revert, then use this. This is useful if you’re reverting 
more than one commit in a row, then you can do it all at once&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-S[&amp;lt;keyid&amp;gt;]/--gpg-sign[=&amp;lt;keyid&amp;gt;]&lt;/code&gt;: the keyid argument is option and 
defaults to the committer identity, but it has to be the no space option. 
The GPG thing is just who is the author&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-s/--signoff&lt;/code&gt;: add a signoff line at the end of the automatically 
created message, this is explained in detail surrounding commit&lt;/li&gt;
  &lt;li&gt;’–strategy=&lt;strategy&gt;&#39;: use the given merge strategy (should only be used once), 
this is the same strategy thing that merge uses&lt;/strategy&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-X&amp;lt;option&amp;gt;/--stategy-option=&amp;lt;option&amp;gt;&lt;/code&gt;: pass the merge strategy-specific 
option to the merge strategy, this is explained more with merge&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;Some basic examples: &lt;code class=&quot;highlighter-rouge&quot;&gt;git revert HEAD~1&lt;/code&gt;: revert the changes of the parent of HEAD and create a new commit.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git revert -n branch~4..branch&lt;/code&gt;: revert all changes done by the last 5 
commits of the branch ‘branch’, but don’t make a commit, just put changes 
in the index and working directory&lt;/p&gt;
</description>
        <pubDate>Thu, 04 Aug 2016 01:50:00 -0500</pubDate>
        <link>http://dmusican.github.io/Elegit/jekyll/update/2016/08/04/what-is-revert.html</link>
        <guid isPermaLink="true">http://dmusican.github.io/Elegit/jekyll/update/2016/08/04/what-is-revert.html</guid>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
      <item>
        <title>What is Git Reset?</title>
        <description>&lt;p&gt;Oh no. I just committed a file containing my username, password, social 
security number, and mother’s maiden name. How do I make sure this never 
sees the light of day? Stack overflow would probably tell you “just do a 
&lt;code class=&quot;highlighter-rouge&quot;&gt;git reset --hard&lt;/code&gt;”. But what does &lt;code class=&quot;highlighter-rouge&quot;&gt;git reset&lt;/code&gt; do?&lt;/p&gt;

&lt;p&gt;The documentation page for reset actually lists the ability to erase 
commits as the last of three usages for reset. These three options are:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-git&quot; data-lang=&quot;git&quot;&gt;git reset [-q] [&amp;lt;tree-ish&amp;gt;] [--] &amp;lt;paths&amp;gt;…​
git reset (--patch | -p) [&amp;lt;tree-ish&amp;gt;] [--] [&amp;lt;paths&amp;gt;…​]
git reset [--soft | --mixed [-N] | --hard | --merge | --keep] [-q] [&amp;lt;commit&amp;gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The first is the way to undo &lt;code class=&quot;highlighter-rouge&quot;&gt;git add&lt;/code&gt;. If you added some file, text.txt, 
that you really didn’t want to add, then typing in &lt;code class=&quot;highlighter-rouge&quot;&gt;git reset HEAD text.txt&lt;/code&gt; 
(or &lt;code class=&quot;highlighter-rouge&quot;&gt;git reset -- text.txt&lt;/code&gt;) will remove text.txt from the index (where 
it got put when you typed &lt;code class=&quot;highlighter-rouge&quot;&gt;git add text.txt&lt;/code&gt;, or did something more complicated 
with the same effect). The &lt;code class=&quot;highlighter-rouge&quot;&gt;-q&lt;/code&gt; is for quiet, which would make Git only output 
errors.&lt;/p&gt;

&lt;p&gt;The next option is if you want to have a little more control over 
what happens, so you could unstage just the password you saved, but not 
the social security number that you want the world to know.&lt;/p&gt;

&lt;p&gt;Finally, option 3 is for undoing entire commits, well, sort of. 
First off, let’s get the usage - if you committed changes, and you just 
want to go back 1 commit, you do a &lt;code class=&quot;highlighter-rouge&quot;&gt;git reset HEAD~1&lt;/code&gt;. What this really 
does is change the file &lt;code class=&quot;highlighter-rouge&quot;&gt;.git/HEAD&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;.git/refs/heads/&amp;lt;current branch&amp;gt;&lt;/code&gt; 
to contain the 40-character hash for the parent of &lt;code class=&quot;highlighter-rouge&quot;&gt;HEAD&lt;/code&gt; instead of the 
hash for &lt;code class=&quot;highlighter-rouge&quot;&gt;HEAD&lt;/code&gt;. You can actually set this to any commit that you know the 
hash for, so like &lt;code class=&quot;highlighter-rouge&quot;&gt;git reset acce7b&lt;/code&gt; will reset to the commit that starts 
with that hash. There are several modes that you can specify here, 
soft, mixed, hard, merge and keep:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;Soft&lt;/em&gt;: only change the repository, don’t change anything in the index or 
working directory.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;Mixed&lt;/em&gt;: (the default) change the repository and reset the files in the 
index to those stored in the commit (yes actually entirely stored in the 
commit, see the commit post).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;Hard&lt;/em&gt;: reset everything! This throws away all changes in the index and 
working directory and replaces them with the files in the commit.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;Merge&lt;/em&gt;: resets the index and files in the working directory to what’s 
stored in the commit, but it keeps files that have unstaged changes in 
the working directory. An error is thrown and the reset stops if a file 
is different between the current commit and the one to reset to and has 
unstaged changes. Usually used to undo a ‘merge operation’.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;Keep&lt;/em&gt;: does a hard reset, but aborts if there are local changes in a file 
that changed between the target commit and the current commit and keeps 
uncommitted changes in the working directory and index.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;Some useful things to know:
&lt;code class=&quot;highlighter-rouge&quot;&gt;Git reset ORIG_HEAD&lt;/code&gt; after a pull or merge to undo it (add &lt;code class=&quot;highlighter-rouge&quot;&gt;--merge&lt;/code&gt; to avoid losing local changes)
If you don’t specify anything, this will just un-stage changes in the index&lt;/p&gt;

&lt;p&gt;What if I want to undo a commit way way back, but not everything in between?
The answer is &lt;code class=&quot;highlighter-rouge&quot;&gt;git revert&lt;/code&gt;– for another day.&lt;/p&gt;
</description>
        <pubDate>Tue, 02 Aug 2016 01:50:00 -0500</pubDate>
        <link>http://dmusican.github.io/Elegit/jekyll/update/2016/08/02/what-is-resert.html</link>
        <guid isPermaLink="true">http://dmusican.github.io/Elegit/jekyll/update/2016/08/02/what-is-resert.html</guid>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
  </channel>
</rss>
